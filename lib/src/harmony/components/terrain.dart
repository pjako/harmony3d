part of game_core;


class TerrainData extends Asset {
  int size;
  int height;
  Texture depth;
  Texture control;
  Texture splat0, splat1, splat2, splat3, splat4;


  void _fromJson(Map obj) {
    var l = [];
    size = obj['size'];
    height = obj['height'];
    depth = Resources.load(obj['depth']);
    control = Resources.load(obj['control']);
    splat0 = Resources.load(obj['splat0']);
    splat1 = Resources.load(obj['splat1']);
    splat2 = Resources.load(obj['splat2']);
    splat3 = Resources.load(obj['splat3']);
    splat4 = Resources.load(obj['splat4']);
    l.add(depth._asyncInformOnLoad());
    l.add(control._asyncInformOnLoad());
    l.add(splat0._asyncInformOnLoad());
    l.add(splat1._asyncInformOnLoad());
    l.add(splat2._asyncInformOnLoad());
    l.add(splat3._asyncInformOnLoad());
    l.add(splat4._asyncInformOnLoad());
    if(l.isEmpty) {
      _isLoaded = true;
      _notifyLoaded();
    } else {
      Future.wait(l).then((val) {
        _isLoaded = true;
        _notifyLoaded();
      });
    }
  }
}

class Terrain extends Renderer {
  TerrainData _terrainData;

  void set terrainData(TerrainData data) {
    _terrainData = data;
    if(data._isLoaded) {
      this._isReadyToRender = true;
    } else {
      this._isReadyToRender = false;
    }
  }


  Material get material => _material;
  void set material(Material newMat) {
    // You cant set this material
  }

  Mesh get mesh => _mesh;
  void set mesh(Mesh newMesh) {
    // Mesh is autogenerated
  }
}


Mesh _getTerrainMesh(double scale, int layer, int ringWidth) {
  String hash = '$scale:$ringWidth:$layer';
  var terrain = _terrainMeshes[hash];
  if(terrain != null) return terrain;
  terrain = _buildTerrainMesh(scale, layer, ringWidth);

  _terrainMeshes[hash] = terrain;

}

final Map<String,Mesh> _terrainMeshes = <String,Mesh>{};


Mesh _buildTerrainMesh(double scale, int layer, int ringWidth) {

    bool terrainhq = false;
    double baseScale;
    int numLayers;
    int ringWidth;
    if(terrainhq) {
      baseScale = scale;//0.5;
      numLayers = layer;
      ringWidth = 15;
    } else {
      baseScale = scale;//1.0;
      numLayers = layer;
      ringWidth = 7;
    }



    var pos2 = [];

    List<int> idx = new List<int>();
    var posn = [];
    var RING_WIDTH = ringWidth;
    var ringSegments = [
      [  1,  0,  0,  1 ],
      [  0, -1,  1,  0 ],
      [ -1,  0,  0, -1 ],
      [  0,  1, -1,  0 ]
    ];
    //double minX, minY, maxX,
    var scale_ = baseScale;
    for(int layer=0; layer < numLayers; layer++) {
      var nextLayer = min(layer + 1, numLayers - 1);
      for(var segment in ringSegments) {
        var rowStart = [];
        var segStart = layer > 0 ? RING_WIDTH + 0 : 0;
        var segWidth = layer > 0 ? RING_WIDTH + 1 : RING_WIDTH * 2 + 1;
        var segLength = layer > 0 ? RING_WIDTH * 3 + 1 : RING_WIDTH * 2 + 1;
        for( int i=0; i <=segLength; i++) {
          rowStart.add( (posn.length ~/ 3));
          var modeli = segStart - i;
          //Draw main part of ring.
          //TODO: Merge vertices between segments.
          for(int j=0; j <= segWidth; j++) {
            var modelj = segStart + j;
            var segi = segment[0] * modeli + segment[1] * modelj;
            var segj = segment[2] * modeli + segment[3] * modelj;
            //pos2.add(segj + 128);
            //pos2.add(segi + 128);
            //pos2.add(layer + 128);
            posn.add(segj.toDouble());
            posn.add(segi.toDouble());
            posn.add(layer.toDouble());
            var m = [ 0, 0, 0, 0 ];
            if(i > 0 && j > 0) {
              var start0 = (rowStart[i-1] + (j-1));
              var start1 = (rowStart[i]   + (j-1));
              if((i + j) % 2 == 1) {
                idx.add( start0 + 1);
                idx.add( start0 + 0);
                idx.add( start1 + 0);

                idx.add( start0 + 1);
                idx.add( start1 + 0);
                idx.add( start1 + 1);
              } else {
                idx.add( start0 + 0);
                idx.add( start1 + 0);
                idx.add( start1 + 1);

                idx.add( start0 + 0);
                idx.add( start1 + 1);
                idx.add( start0 + 1);
              }
            }
          }
        }
      }
      scale_ *= 2;
    }

    var mesh = new Mesh();
    mesh._isLoaded = true;
    mesh._parameters._indexArrayBuffer = new Uint16List.fromList(idx);
    mesh._parameters._vertexArrayBuffer = new Float32List.fromList(posn);
    mesh._parameters.attributes['position'] = new MeshAttribute('position', 'float3', 0, 12);
    return mesh;

    /*
    var l = pos2.length / 4;
    l = (l - l.floorToDouble()) / 0.25;
    for(int i=l.floor(); i > 0; i--) {
      pos2.add(0);
    }
    */
    /*terrainMesh = new SingleArrayIndexedMesh('terrain', device);
    terrainMesh.indexArray.uploadData(new Uint16List.fromList(idx), UsagePattern.StaticDraw);
    terrainMesh.vertexArray.uploadData(new Float32List.fromList(posn), UsagePattern.StaticDraw);
    terrainMesh.count = idx.length;
    print('index count: ${idx.length}');
    print(idx.last);
    print('vertex count: ${posn.length}');
    print(posn.last);
    terrainMesh.attributes['position'] = new SpectreMeshAttribute('position',
        new VertexAttribute(0, 0, 0, 3*4, DataType.Float32, 3,
            false));
    //print(idx);
    //print(posn);
     *
     */


    //new Uint8List.fromList(pos2);

    //print();
    //print(new Uint16List.fromList(idx));
    //#geom.removeIndices()
   // geom.updateOffsets()
    //return geom;
}

